% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/delete_censoring.R
\name{delete_MAR_censoring}
\alias{delete_MAR_censoring}
\title{Create MAR values using a censoring mechanism}
\usage{
delete_MAR_censoring(
  ds,
  p,
  miss_cols,
  ctrl_cols,
  where = "lower",
  sorting = TRUE
)
}
\arguments{
\item{ds}{a data frame or matrix in which missing values will be created}

\item{p}{a numeric vector with length one or equal to length \code{miss_cols};
the probability that a value is missing}

\item{miss_cols}{a vector of column names or indices of columns in which
missing values will be created}

\item{ctrl_cols}{a vector of column names or indices of columns, which
controls the creation of missing values in \code{miss_cols}. Must be of the
same length as \code{miss_cols}.}

\item{where}{controls where missing values are created; one of "lower",
"upper" or "both" (see details)}

\item{sorting}{logical; should sorting be used or a quantile as a threshold}
}
\value{
An object of the same class as \code{ds} with missing values
}
\description{
Create missing at random (MAR) values using a censoring mechanism in a data
frame or a matrix
}
\details{
This function creates missing at random (MAR) values in the columns
specified by the argument \code{miss_cols}.
The probability for missing values is controlled by \code{p}.
If \code{p} is a single number, then the overall probability for a value to
be missing will be \code{p} in all columns of \code{miss_cols}.
(Internally \code{p} will be replicated to a vector of the same length as
\code{miss_cols}.
So, all \code{p[i]} in the following sections will be equal to the given
single number \code{p}.)
Otherwise, \code{p} must be of the same length as \code{miss_cols}.
In this case, the overall probability for a value to be missing will be
\code{p[i]} in the column \code{miss_cols[i]}.
The position of the missing values in \code{miss_cols[i]} is controlled by
\code{ctrl_cols[i]}.
The following procedure is applied for each pair of \code{ctrl_cols[i]} and
\code{miss_cols[i]} to determine the positions of missing values:

If \code{sorting = TRUE} (the default), the column
\code{ctrl_cols[i]} will be sorted. Then the rows with the
\code{round(nrow(ds) * p[i])} smallest values will be selected (if
\code{where = "lower"} (the default)). Now missing values will be created in
the column \code{miss_cols[i]} in these rows. This effectively censors the
proportion of \code{p[i]} rows of smallest values in \code{ctrl_cols[i]} in
\code{miss_cols[i]}.

If \code{where = "upper"}, instead of the rows with the smallest values, the
rows with the highest values will be selected. For \code{where = "both"}, the
one half of the \code{round(nrow(ds) * p[i])} rows with missing values will
be the rows with the smallest values and the other half will be the rows with
the highest values. So the censoring rows are dived to the highest and
smallest values of \code{ctrl_cols[i]}.

If \code{sorting = FALSE}, the rows of \code{ds} will not be sorted. Instead,
a quantile will be calculated (using \code{\link[stats]{quantile}}). If
\code{where = "lower"}, the \code{quantile(ds[, ctrl_cols[i]], p[i])} will be
calculated and all rows with values in \code{ds[, ctrl_cols[i]]} below this
quantile will have missing values in \code{miss_cols[i]}. For \code{where =
"upper"}, the \code{quantile(ds[, ctrl_cols[i]], 1 - p[i])} will be
calculated and all rows with values above this quantile will have missing
values. For \code{where = "both"}, the \code{quantile(ds[, ctrl_cols[i]],
p[i] / 2)} and \code{quantile(ds[, ctrl_cols[i]], 1 -  p[i] / 2)} will be
calculated. All rows with values in \code{ctrl_cols[i]} below the first
quantile or above the second quantile will have missing values in
\code{miss_cols[i]}.

The option \code{sorting = TRUE} will always create exactly
\code{round(nrow(ds) * p[i])} missing values in \code{miss_cols[i]}. For
\code{sorting = FALSE}, the number of missing values will normally be close
to \code{nrow(ds) * p[i]}. But for \code{ctrl_cols} with many duplicates the
choice \code{sorting = FALSE} can be problematic, because of the calculation
of \code{quantile(ds[, ctrl_cols[i]], p[i])} and setting values \code{NA}
below this threshold (see examples). So, in most cases \code{sorting = TRUE}
is recommended.
}
\examples{
ds <- data.frame(X = 1:20, Y = 101:120)
delete_MAR_censoring(ds, 0.2, "X", "Y")
# many dupplicated values can be problematic for sorting = FALSE:
ds_many_dup <- data.frame(X = 1:20, Y = c(rep(0, 10), rep(1, 10)))
delete_MAR_censoring(ds_many_dup, 0.2, "X", "Y") # 4 NAs as expected
quantile(ds_many_dup$Y, 0.2) # 0
# No value is BELOW 0 in ds_many_dup$Y, so no missing values will be created:
delete_MAR_censoring(ds_many_dup, 0.2, "X", "Y", sorting = FALSE) # No NA!
}
\references{
Santos, M. S., Pereira, R. C., Costa, A. F., Soares, J. P.,
Santos, J., & Abreu, P. H. (2019). Generating Synthetic Missing Data: A
Review by Missing Mechanism. \emph{IEEE Access}, 7, 11651-11667
}
\seealso{
\code{\link{delete_MNAR_censoring}}

Other functions to create MAR: 
\code{\link{delete_MAR_1_to_x}()},
\code{\link{delete_MAR_one_group}()},
\code{\link{delete_MAR_rank}()}
}
\concept{functions to create MAR}
